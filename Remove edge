#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Graph {
public:
    int V;  
    vector<vector<int>> adjList;

    Graph(int V) {
        this->V = V;
        adjList.resize(V);
    }

    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    void DFS(int v, vector<bool>& visited, vector<int>& parent) {
        visited[v] = true;

        for (int neighbor : adjList[v]) {
            if (!visited[neighbor]) {
                parent[neighbor] = v;  
                cout << "Edge in spanning tree: (" << v << ", " << neighbor << ")" << endl;
                DFS(neighbor, visited, parent);
            }
        }
    }

    void printSpanningTree() {
        vector<bool> visited(V, false);
        vector<int> parent(V, -1); 

        cout << "Spanning Tree Edges:" << endl;
      
        for (int i = 0; i < V; i++) {
            if (!visited[i]) {
                DFS(i, visited, parent);
            }
        }
    }
};

int main() {
    int rows = 50;
    int cols = 600;
  
    int V = (rows + 1) * (cols + 1); 

    Graph g(V){
    for (int i = 0; i <= rows; i++) {
        for (int j = 0; j <= cols; j++) {
            int currentVertex = i * (cols + 1) + j;
            if (j < cols) {  
                int rightVertex = currentVertex + 1;
                g.addEdge(currentVertex, rightVertex);
            }
            if (i < rows) {  
                int downVertex = currentVertex + (cols + 1);
                g.addEdge(currentVertex, downVertex);
            }
        }
    }

    g.printSpanningTree();

    int totalEdges = 60650;

    int edgesInSpanningTree = V - 1;  

    int maxEdgesToRemove = totalEdges - edgesInSpanningTree;

    cout << "Maximum number of edges that can be removed: " << maxEdgesToRemove << endl;

    return 0;
}
